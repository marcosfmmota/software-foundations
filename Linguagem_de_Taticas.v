Require Export IndPrinciples.


(** * Alguns Taticais da Linguagem de Táticas do Coq (LTAC) *)

(** Do livro "Coq'Art", páginas 61 e 62:

----------------------------------------------------------------------
Until now, we have presented proof scripts where only elementary calls
to tactics are made at each interaction. This can lead to very long
proof scripts. The Coq system provides a collection of operators that
make it possible to combine tactics. By analogy with the functional
programming jargon, where functions taking functions as arguments are
called functionals, we will call these operators tacticals, which take
tactics as arguments to return new tactics. Using tacticals,
interactive proofs are much more concise and readable.
----------------------------------------------------------------------
*)


(** De

https://coq.inria.fr/distrib/current/refman/Reference-Manual011.html#hevea_default761

----------------------------------------------------------------------
Sequence

A sequence is an expression of the following form:

    expr1 ; expr2 

The expressions expr1 and expr2 are evaluated to v1 and v2 which have
to be tactic values. The tactic v1 is then applied and v2 is applied
to the goals generated by the application of v1. Sequence is
left-associative.
----------------------------------------------------------------------

Esse operador é útil, por exemplo, quando desejamos resolver vários
objetivos de prova usando o mesmo argumento, como neste exemplo: *)

Theorem negb_negb : forall b : bool, negb (negb b) = b.
Proof.
  intros.
  (* Aqui, "reflexivity" não resolve o objetivo de prova, e antes nós
     fazíamos:

       destruct b.
       - reflexivity.
       - reflexivity.

     Isso pode ser simplificado assim:
  *)
  destruct b; reflexivity.
  Qed.


(* ------------------------------------------------------ *)

(** Agora, como motivação para taticais de repetição, considere: *)

Theorem le_0_5: 0 <= 5.
Proof.
  (* Recapitule:  Inductive le (n : nat) : nat -> Prop :=
                  | le_n : n <= n
                  | le_S : forall m : nat, n <= m -> n <= S m
                  End
  *)
  apply le_S, le_S, le_S, le_S, le_S, le_n.
  Qed.


(** De

https://coq.inria.fr/distrib/current/refman/Reference-Manual011.html#hevea_default769

----------------------------------------------------------------------
Repeat loop

We have a repeat loop with:

    repeat expr

expr is evaluated to v. If v denotes a tactic, this tactic is applied
to each focused goal independently. If the application succeeds, the
tactic is applied recursively to all the generated subgoals until it
eventually fails. The recursion stops in a subgoal when the tactic has
failed to make progress. The tactic repeat expr itself never fails.
----------------------------------------------------------------------

Aplicando esse operador ao exemplo acima, temos: *)

Theorem le_0_5_do: 0 <= 5.
Proof. repeat (apply le_S). apply le_n. Qed.


(* O raciocínio acima pode ser embutido numa tática assim: *)

Ltac by_le_S_le_n := repeat (apply le_S); apply le_n.

(** Observe que, na tática acima, nós usamos o operador ";" .
    O que acontece se o substituirmos por um "." ? *)

(** Aplicando a tática acima: *)

Theorem n_eq_5_or_n_eq_7__0_le_n: forall n, n = 5 \/ n = 7 -> 0 <= n.
Proof.
  intros n hor.
  destruct hor as [hn | hn]; rewrite hn; by_le_S_le_n.
  Qed.

(** OBSERVE O ENCADEAMENTO DO OPERADOR ";" ACIMA, para que cada
    argumento seja aplicado aos 2 casos do [destruct]. *)


(* ------------------------------------------------------ *)


(** De

https://coq.inria.fr/distrib/current/refman/Reference-Manual011.html#hevea_tactic202

----------------------------------------------------------------------
Error catching

We can catch the tactic errors with:

    try expr

expr is evaluated to v which must be a tactic value. The tactic value
v is applied to each focused goal independently. If the application of
v fails in a goal, it catches the error and leaves the goal unchanged.
If the level of the exception is positive, then the exception is
re-raised with its level decremented.
----------------------------------------------------------------------

Essa tática é útil, por exemplo, quando:

  * Queremos dar essencialmente o mesmo argumento em casos diferentes,
  * Mas, em alguns casos, algo de particular precisa ser dito,
  * E o argumento dos casos particulares levaria a um erro nos outros
    casos.

Exemplo: *)

Theorem plus_0_r_try: forall n, n + 0 = n.
Proof.
  (* Uma prova possível é:  induction n as [| m HI].
                            - simpl. reflexivity.
                            - simpl. rewrite HI. reflexivity.
                            Qed.

  *)
  induction n as [| n' HI]; simpl; try (rewrite HI); reflexivity.
  Qed.

(** Observe que, na prova acima, o argumento "rewrite HI" é tentado em
    ambos os casos. No caso base (n = 0), esse argumento resulta em
    erro, o qual é então capturado pelo "try". *)


(* ------------------------------------------------------ *)

(** Observe que o tatical [try] só deixa o contexto inalterado em caso
    de falha, mas às vezes nós só desejamos usar um certo argumento
    caso ele _conclua_ o objetivo de prova.

    Na falta de um exemplo concreto simples e adequado, considere a
    seguinte situação, artificialmente criada: *)

Definition f_exemplo (n : nat) : bool :=
  match n with
  | 3 => false
  | _ => true
  end.

Theorem exemplo_try: f_exemplo(1) = f_exemplo(2).
Proof.
  try(apply f_equal). (* Suponha que esse argumento fosse usado numa
                         tática, etc. Agora, a prova é impossível! *)
  Abort.


(** De

https://coq.inria.fr/distrib/current/refman/Reference-Manual011.html#hevea_tactic210

----------------------------------------------------------------------
Solving

We may consider the first to solve (i.e. which generates no subgoal)
among a panel of tactics:

    solve [ expr1 | ... | exprn ]

expri are evaluated to vi and vi must be tactic values, for i=1,...,n.
Supposing n>1, it applies v1 to each goal independently, if it doesn’t
solve the goal then it tries to apply v2 and so on. It fails if there
is no solving tactic.

----------------------------------------------------------------------

Essa tática pode ser usada como abaixo: *)

Theorem exemplo_try: f_exemplo(1) = f_exemplo(2).
Proof.
  try(solve[apply f_equal]).  (* A prova ainda é possível! *)
  simpl. reflexivity.
  Qed.


(* ================================================================ *)

(** * Táticas com Casamento de Padrão *)

(** Em muitos contextos de prova, o objetivo de prova já está entre as
    hipóteses, e basta fazer "apply ..." sobre a hipótese correta.
    A tática [assumption] faz isso por nós, sem que tenhamos que
    escrever o nome da hipótese, o que é útil não apenas pela economia
    de digitação, mas pela própria manutenção da prova: na versão
    "manual", se mudarmos o nome da hipótese ao fazer "intros ...",
    então teremos que mudar também no "apply ..."; isso não ocorre se
    usarmos [assumption]. Nesse último caso, aliás, pode nem ser
    necessário dar nomes específicos às hipóteses. Exemplo: *)

Theorem P_Q__P_and_Q: forall P Q : Prop, P -> Q -> P /\ Q.
Proof.
  intros; split; assumption. Qed.


(** Observe como [assumption] poderia ser definida: *)

Ltac my_assumption := match goal with
                      | [H: ?T |- ?T] => apply H
                      end.

Theorem P_Q__P_and_Q_my_assumption: forall P Q : Prop, P -> Q -> P /\ Q.
Proof.
  intros; split; my_assumption. Qed.


(** Outra tática útil é a [contradiction], que detecta contradições

      hsim: P
      hnao: ~P

    evitando que tenhamos que escrever

      [apply hnao in hsim; inversion hsim.]

    Exemplo: *)
                         

Theorem example_contradiction: forall P Q : Prop, P -> ~P -> Q.
Proof.
  intros; contradiction. Qed.


(** EXERCÍCIO: Usando casamento de padrão

      [ h1 : t1 , h2 : t2 ... |- C ] => tac

    e lembrando da possibilidade de usar [_] para representar objetos
    cuja instância particular não importa, escreva a sua própria
    definição para a tática [contradiction], e aplique-a para provar
    um teorema baseado em contradição. *)

Ltac my_contradiction := match goal with
                         | [H1 : ?T, H2 : ~?T |- ?C] => apply H2 in H1; inversion H1
                         end. 

Theorem example_contradiction': forall P Q : Prop, P -> ~P -> Q.
Proof.
  intros; my_contradiction. Qed.

(** EXERCÍCIO: Usando o fato de que táticas podem ser RECURSIVAS e
               podem ter vários casos no "match goal", escreva uma
    tática que resolva contextos do tipo

      h1: P1
      h2: P2
      ...
      hn: Pn
      ________________
      P1 /\ P2 /\ ... /\ Pn *)